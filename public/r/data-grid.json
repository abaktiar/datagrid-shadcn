{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-grid",
  "type": "registry:component",
  "title": "Data Grid",
  "description": "A feature-rich, composable data grid built with TanStack Table v8, shadcn/ui, and Tailwind CSS. Supports sorting, filtering, pagination, row selection, bulk actions, context menus, and inline cell editing with configurable behaviors.",
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/react-virtual",
    "lucide-react",
    "class-variance-authority",
    "clsx",
    "tailwind-merge"
  ],
  "registryDependencies": [
    "button",
    "checkbox",
    "input",
    "select",
    "context-menu",
    "dropdown-menu"
  ],
  "files": [
    {
      "path": "src/components/data-grid/data-grid.tsx",
      "content": "'use client';\n\nimport React, { useMemo, useState } from 'react';\nimport {\n  useReactTable,\n  getCoreRowModel,\n  getSortedRowModel,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  ColumnFiltersState,\n  SortingState,\n  VisibilityState,\n  RowSelectionState,\n  PaginationState,\n  Table,\n  Row,\n} from '@tanstack/react-table';\nimport { cn } from '../../lib/utils';\nimport { Checkbox } from '../ui/checkbox';\nimport { DataGridProps, DataGridContextValue } from './types';\nimport { DataGridContext } from './context';\nimport { DataGridHeader } from './data-grid-header';\nimport { DataGridBody } from './data-grid-body';\nimport { DataGridPagination } from './data-grid-pagination';\nimport { DataGridActionDock } from './data-grid-action-dock';\nimport { DataGridFilters } from './data-grid-filters';\n\nexport function DataGrid<TData>({\n  data,\n  columns,\n  enableRowSelection = false,\n  enableMultiRowSelection = true,\n  onRowSelectionChange,\n  actions = [],\n  cellContextMenuItems,\n  headerContextMenuItems,\n  enableCellContextMenu = false,\n  enableHeaderContextMenu = false,\n  enablePagination = true,\n  pageSize = 10,\n  pageSizeOptions = [10, 20, 50, 100],\n  manualPagination = false,\n  pageCount,\n  totalCount,\n  onPaginationChange,\n  onDataChange,\n  enableSorting = true,\n  enableMultiSort = false,\n  manualSorting = false,\n  onSortingChange,\n  enableGlobalFilter = true,\n  enableColumnFilters = true,\n  manualFiltering = false,\n  onGlobalFilterChange,\n  onColumnFiltersChange,\n  enableCellEditing = false,\n  defaultEditMode = 'click',\n  onCellEdit,\n  onCellEditError,\n  enableColumnResizing = true,\n  onColumnSizingChange,\n  enableVirtualization = false,\n  estimateSize = 35,\n  isLoading = false,\n  error = null,\n  className,\n  'aria-label': ariaLabel = 'Data grid',\n  'aria-describedby': ariaDescribedBy,\n}: DataGridProps<TData>) {\n  // State management\n  const [rowSelection, setRowSelection] = useState<RowSelectionState>({});\n  const [sorting, setSorting] = useState<SortingState>([]);\n  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);\n  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>({});\n  const [columnSizing, setColumnSizing] = useState<Record<string, number>>({});\n  const [globalFilter, setGlobalFilter] = useState('');\n  const [pagination, setPagination] = useState<PaginationState>({\n    pageIndex: 0,\n    pageSize,\n  });\n  const [editingCell, setEditingCell] = useState<{ rowId: string; columnId: string } | null>(null);\n\n  // Enhanced columns with selection column if needed\n  const enhancedColumns = useMemo(() => {\n    const cols = [...columns];\n    if (enableRowSelection) {\n      cols.unshift({\n        id: 'select',\n        header: ({ table }: { table: Table<TData> }) => (\n          <div className='flex items-center justify-center'>\n            <Checkbox\n              checked={\n                table.getIsAllPageRowsSelected() ? true : table.getIsSomePageRowsSelected() ? 'indeterminate' : false\n              }\n              onCheckedChange={(checked) => {\n                if (checked === 'indeterminate') {\n                  return;\n                }\n                table.toggleAllPageRowsSelected(checked);\n              }}\n              aria-label='Select all rows'\n              className='size-3.5'\n            />\n          </div>\n        ),\n        cell: ({ row }: { row: Row<TData> }) => (\n          <div className='flex items-center justify-center'>\n            <Checkbox\n              checked={row.getIsSelected()}\n              onCheckedChange={(checked) => {\n                if (checked === 'indeterminate') {\n                  return;\n                }\n                row.toggleSelected(checked);\n              }}\n              aria-label={`Select row ${row.index + 1}`}\n              className='size-3.5'\n            />\n          </div>\n        ),\n        enableSorting: false,\n        enableHiding: false,\n        size: 60,\n      } as any);\n    }\n\n    return cols;\n  }, [columns, enableRowSelection]);\n  // Table instance\n  const table = useReactTable({\n    data,\n    columns: enhancedColumns as any,\n    state: {\n      rowSelection,\n      sorting,\n      columnFilters,\n      columnVisibility,\n      columnSizing,\n      globalFilter,\n      pagination,\n    },\n    enableRowSelection,\n    enableMultiRowSelection,\n    enableColumnResizing,\n    columnResizeMode: 'onChange',\n    onRowSelectionChange: setRowSelection,\n    onSortingChange: setSorting,\n    onColumnFiltersChange: setColumnFilters,\n    onColumnVisibilityChange: setColumnVisibility,\n    onColumnSizingChange: setColumnSizing,\n    onGlobalFilterChange: setGlobalFilter,\n    onPaginationChange: setPagination,\n    getCoreRowModel: getCoreRowModel(),\n    getSortedRowModel: enableSorting ? getSortedRowModel() : undefined,\n    getFilteredRowModel: enableGlobalFilter || enableColumnFilters ? getFilteredRowModel() : undefined,\n    getPaginationRowModel: enablePagination ? getPaginationRowModel() : undefined,\n    manualPagination,\n    manualSorting,\n    manualFiltering,\n    pageCount: pageCount ?? -1,\n    meta: {\n      totalCount,\n    },\n    getRowId: (row, index) => {\n      // Use a unique identifier if available, otherwise fall back to index\n      return (row as any).id?.toString() ?? index.toString();\n    },\n  });\n\n  // Selected rows\n  const selectedRows = useMemo(() => {\n    return table.getFilteredSelectedRowModel().rows;\n  }, [table, rowSelection]);\n\n  // Context value\n  const contextValue: DataGridContextValue<TData> = useMemo(\n    () => ({\n      table,\n      selectedRows,\n      actions,\n      cellContextMenuItems,\n      headerContextMenuItems,\n      enableCellContextMenu,\n      enableHeaderContextMenu,\n      enableCellEditing,\n      defaultEditMode,\n      editingCell,\n      setEditingCell,\n      onCellEdit,\n      onCellEditError,\n      isLoading,\n      error,\n    }),\n    [\n      table,\n      selectedRows,\n      actions,\n      cellContextMenuItems,\n      headerContextMenuItems,\n      enableCellContextMenu,\n      enableHeaderContextMenu,\n      enableCellEditing,\n      defaultEditMode,\n      editingCell,\n      setEditingCell,\n      onCellEdit,\n      onCellEditError,\n      isLoading,\n      error,\n    ]\n  );\n\n  // Handle external callbacks\n  React.useEffect(() => {\n    onRowSelectionChange?.(selectedRows);\n  }, [selectedRows, onRowSelectionChange]);\n\n  React.useEffect(() => {\n    onSortingChange?.(sorting);\n  }, [sorting, onSortingChange]);\n\n  React.useEffect(() => {\n    onColumnFiltersChange?.(columnFilters);\n  }, [columnFilters, onColumnFiltersChange]);\n\n  React.useEffect(() => {\n    onGlobalFilterChange?.(globalFilter);\n  }, [globalFilter, onGlobalFilterChange]);\n\n  React.useEffect(() => {\n    onPaginationChange?.(pagination.pageIndex, pagination.pageSize);\n  }, [pagination, onPaginationChange]);\n\n  React.useEffect(() => {\n    onColumnSizingChange?.(columnSizing);\n  }, [columnSizing, onColumnSizingChange]);\n\n  // Server-side data change effect\n  React.useEffect(() => {\n    if (onDataChange && (manualPagination || manualSorting || manualFiltering)) {\n      const params = {\n        pagination: {\n          pageIndex: pagination.pageIndex,\n          pageSize: pagination.pageSize,\n        },\n        sorting: sorting.map((sort) => ({\n          id: sort.id,\n          desc: sort.desc,\n        })),\n        filters: columnFilters.map((filter) => ({\n          id: filter.id,\n          value: filter.value,\n        })),\n        globalFilter,\n      };\n      onDataChange(params);\n    }\n  }, [\n    pagination,\n    sorting,\n    columnFilters,\n    globalFilter,\n    onDataChange,\n    manualPagination,\n    manualSorting,\n    manualFiltering,\n  ]);\n\n  return (\n    <DataGridContext.Provider value={contextValue}>\n      <div\n        className={cn('space-y-4', className)}\n        role='region'\n        aria-label={ariaLabel}\n        aria-describedby={ariaDescribedBy}>\n        {/* Global Filter and Column Visibility */}\n        {(enableGlobalFilter || enableColumnFilters) && (\n          <DataGridFilters\n            enableGlobalFilter={enableGlobalFilter}\n            enableColumnFilters={enableColumnFilters}\n            globalFilter={globalFilter}\n            onGlobalFilterChange={setGlobalFilter}\n          />\n        )}\n\n        {/* Table */}\n        <div className='rounded-md border border-border bg-background'>\n          <div className='relative overflow-auto'>\n            <table\n              className='w-full caption-bottom text-sm border-collapse'\n              role='grid'\n              aria-rowcount={table.getRowModel().rows.length}\n              style={{\n                width: table.getCenterTotalSize(),\n              }}>\n              <DataGridHeader />\n              <DataGridBody enableVirtualization={enableVirtualization} estimateSize={estimateSize} />\n            </table>\n          </div>\n        </div>\n\n        {/* Pagination */}\n        {enablePagination && <DataGridPagination pageSizeOptions={pageSizeOptions} />}\n      </div>\n\n      {/* Fixed Bottom Action Dock */}\n      {enableRowSelection && selectedRows.length > 0 && actions.length > 0 && <DataGridActionDock />}\n    </DataGridContext.Provider>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/data-grid-header.tsx",
      "content": "'use client';\n\nimport { flexRender } from '@tanstack/react-table';\nimport { ArrowUpDown, ArrowUp, ArrowDown } from 'lucide-react';\nimport { cn } from '../../lib/utils';\nimport { useDataGrid } from './context';\nimport { HeaderContextMenu } from './data-grid-context-menu';\n\nexport function DataGridHeader() {\n  const { table, headerContextMenuItems, enableHeaderContextMenu } = useDataGrid();\n\n  return (\n    <thead className='[&_tr]:border-b bg-muted/30'>\n      {table.getHeaderGroups().map((headerGroup) => (\n        <tr key={headerGroup.id} role='row'>\n          {headerGroup.headers.map((header) => {\n            const canSort = header.column.getCanSort();\n            const sortDirection = header.column.getIsSorted();\n\n            const headerContent = (\n              <th\n                role='columnheader'\n                aria-sort={\n                  sortDirection === 'asc'\n                    ? 'ascending'\n                    : sortDirection === 'desc'\n                    ? 'descending'\n                    : canSort\n                    ? 'none'\n                    : undefined\n                }\n                className={cn(\n                  'h-10 px-3 text-left align-middle font-medium text-foreground text-sm relative border-r border-border/50',\n                  '[&:has([role=checkbox])]:pr-0',\n                  header.column.id === 'select' && 'border-r-0',\n                  header.column.getIsResizing() && 'w-2 border-r-primary',\n                  canSort && 'cursor-pointer select-none hover:bg-muted/50'\n                )}\n                style={{\n                  width: header.getSize(),\n                  minWidth: header.column.columnDef.minSize || 50,\n                  maxWidth: header.column.columnDef.maxSize || 500,\n                }}\n                onClick={canSort ? header.column.getToggleSortingHandler() : undefined}>\n                <div className='flex items-center space-x-2'>\n                  <div className='flex-1'>\n                    {header.isPlaceholder ? null : flexRender(header.column.columnDef.header, header.getContext())}\n                  </div>\n\n                  {canSort && (\n                    <div className='flex items-center'>\n                      {sortDirection === 'asc' ? (\n                        <ArrowUp className='h-4 w-4' />\n                      ) : sortDirection === 'desc' ? (\n                        <ArrowDown className='h-4 w-4' />\n                      ) : (\n                        <ArrowUpDown className='h-4 w-4 opacity-50' />\n                      )}\n                    </div>\n                  )}\n                </div>\n\n                {/* Column Resizer */}\n                {header.column.getCanResize() && (\n                  <div\n                    onMouseDown={header.getResizeHandler()}\n                    onTouchStart={header.getResizeHandler()}\n                    className={cn(\n                      'absolute right-0 top-0 h-full w-2 cursor-col-resize select-none touch-none',\n                      'bg-transparent hover:bg-transparent transition-colors duration-150',\n                      'before:absolute before:left-1/2 before:top-0 before:h-full before:w-px',\n                      'before:bg-border/50 before:transform before:-translate-x-1/2 before:transition-colors before:duration-150',\n                      'hover:before:bg-primary',\n                      header.column.getIsResizing() && 'before:bg-primary'\n                    )}\n                    style={{\n                      transform: 'translateX(50%)',\n                    }}\n                    title={`Resize ${header.column.columnDef.header} column`}\n                  />\n                )}\n              </th>\n            );\n\n            return enableHeaderContextMenu && headerContextMenuItems ? (\n              <HeaderContextMenu key={header.id} column={header.column} items={headerContextMenuItems}>\n                {headerContent}\n              </HeaderContextMenu>\n            ) : (\n              headerContent\n            );\n          })}\n        </tr>\n      ))}\n    </thead>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/data-grid-body.tsx",
      "content": "'use client';\n\nimport { useRef } from 'react';\nimport { flexRender } from '@tanstack/react-table';\nimport { useVirtualizer } from '@tanstack/react-virtual';\nimport { cn } from '../../lib/utils';\nimport { useDataGrid } from './context';\nimport { CellContextMenu } from './data-grid-context-menu';\nimport { EditableCell } from './data-grid-editable-cell';\nimport { CellEditConfig } from './types';\n\ninterface DataGridBodyProps {\n  enableVirtualization?: boolean;\n  estimateSize?: number;\n}\n\nexport function DataGridBody({ enableVirtualization = false, estimateSize = 35 }: DataGridBodyProps) {\n  const { table, isLoading, error, cellContextMenuItems, enableCellContextMenu, enableCellEditing } = useDataGrid();\n  const tableContainerRef = useRef<HTMLTableSectionElement>(null);\n\n  const rows = table.getRowModel().rows;\n\n  // Helper function to render cell content\n  const renderCellContent = (cell: any) => {\n    const column = cell.column;\n    const row = cell.row;\n    const value = cell.getValue();\n\n    // Check if this column has editing enabled\n    const columnDef = column.columnDef as any;\n    const editConfig = columnDef.enableEditing;\n\n    if (enableCellEditing && editConfig) {\n      // Determine edit configuration\n      const config: CellEditConfig<any> =\n        typeof editConfig === 'boolean' ? { enabled: true } : { enabled: true, ...editConfig };\n\n      return <EditableCell row={row} column={column} value={value} editConfig={config} />;\n    }\n\n    // Default cell rendering\n    return flexRender(column.columnDef.cell, cell.getContext());\n  };\n\n  // Virtualization setup\n  const rowVirtualizer = useVirtualizer({\n    count: rows.length,\n    getScrollElement: () => tableContainerRef.current,\n    estimateSize: () => estimateSize,\n    enabled: enableVirtualization && rows.length > 50, // Only virtualize for large datasets\n  });\n\n  // Loading state\n  if (isLoading) {\n    return (\n      <tbody ref={tableContainerRef}>\n        <tr>\n          <td colSpan={table.getAllColumns().length} className='h-24 text-center text-muted-foreground'>\n            <div className='flex items-center justify-center space-x-2'>\n              <div className='h-4 w-4 animate-spin rounded-full border-2 border-primary border-t-transparent' />\n              <span>Loading...</span>\n            </div>\n          </td>\n        </tr>\n      </tbody>\n    );\n  }\n\n  // Error state\n  if (error) {\n    return (\n      <tbody ref={tableContainerRef}>\n        <tr>\n          <td colSpan={table.getAllColumns().length} className='h-24 text-center text-destructive'>\n            <div className='flex items-center justify-center space-x-2'>\n              <span>Error: {error}</span>\n            </div>\n          </td>\n        </tr>\n      </tbody>\n    );\n  }\n\n  // Empty state\n  if (rows.length === 0) {\n    return (\n      <tbody ref={tableContainerRef}>\n        <tr>\n          <td colSpan={table.getAllColumns().length} className='h-24 text-center text-muted-foreground'>\n            No data available\n          </td>\n        </tr>\n      </tbody>\n    );\n  }\n\n  // Virtualized rendering\n  if (enableVirtualization && rowVirtualizer.getVirtualItems().length > 0) {\n    const virtualItems = rowVirtualizer.getVirtualItems();\n\n    return (\n      <tbody\n        ref={tableContainerRef}\n        style={{\n          height: `${rowVirtualizer.getTotalSize()}px`,\n          position: 'relative',\n        }}>\n        {virtualItems.map((virtualItem) => {\n          const row = rows[virtualItem.index];\n          return (\n            <tr\n              key={row.id}\n              role='row'\n              aria-rowindex={virtualItem.index + 2} // +2 because header is row 1\n              aria-selected={row.getIsSelected()}\n              className={cn(\n                'border-b border-border hover:bg-muted/50', // Base styling\n                row.getIsSelected() && 'data-[state=selected]:bg-accent data-[state=selected]:text-accent-foreground' // Updated dark mode selected style\n              )}\n              data-state={row.getIsSelected() ? 'selected' : ''}\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: `${virtualItem.size}px`,\n                transform: `translateY(${virtualItem.start}px)`,\n              }}>\n              {row.getVisibleCells().map((cell) => (\n                <CellContextMenu\n                  key={cell.id}\n                  row={row}\n                  column={cell.column}\n                  value={cell.getValue()}\n                  items={enableCellContextMenu ? cellContextMenuItems : []}>\n                  <td\n                    role='gridcell'\n                    className={cn(\n                      'px-3 py-1.5 align-middle text-sm border-r border-border/50 [&:has([role=checkbox])]:pr-0',\n                      cell.column.id === 'select' && 'w-12 border-r-0'\n                    )}\n                    style={{\n                      width: cell.column.getSize(),\n                      minWidth: cell.column.columnDef.minSize || 50,\n                      maxWidth: cell.column.columnDef.maxSize || 500,\n                    }}>\n                    {renderCellContent(cell)}\n                  </td>\n                </CellContextMenu>\n              ))}\n            </tr>\n          );\n        })}\n      </tbody>\n    );\n  }\n\n  // Standard rendering\n  return (\n    <tbody ref={tableContainerRef}>\n      {rows.map((row) => (\n        <tr\n          key={row.id}\n          role='row'\n          aria-rowindex={row.index + 2} // +2 because header is row 1\n          aria-selected={row.getIsSelected()}\n          className={cn(\n            'border-b border-border hover:bg-muted/50', // Base styling\n            row.getIsSelected() && 'data-[state=selected]:bg-accent data-[state=selected]:text-accent-foreground' // Updated dark mode selected style\n          )}\n          data-state={row.getIsSelected() ? 'selected' : ''}>\n          {row.getVisibleCells().map((cell) => (\n            <CellContextMenu\n              key={cell.id}\n              row={row}\n              column={cell.column}\n              value={cell.getValue()}\n              items={enableCellContextMenu ? cellContextMenuItems : []}>\n              <td\n                role='gridcell'\n                className={cn(\n                  'px-3 py-1.5 align-middle text-sm border-r border-border/50 [&:has([role=checkbox])]:pr-0',\n                  cell.column.id === 'select' && 'w-12 border-r-0',\n                  cell.column.getIsResizing() && 'w-2 border-r-primary'\n                )}\n                style={{\n                  width: cell.column.getSize(),\n                  minWidth: cell.column.columnDef.minSize || 50,\n                  maxWidth: cell.column.columnDef.maxSize || 500,\n                }}>\n                {renderCellContent(cell)}\n              </td>\n            </CellContextMenu>\n          ))}\n        </tr>\n      ))}\n    </tbody>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/data-grid-pagination.tsx",
      "content": "import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react'\nimport { Button } from '../ui/button';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';\nimport { useDataGrid } from './context'\n\ninterface DataGridPaginationProps {\n  pageSizeOptions?: number[]\n}\n\nexport function DataGridPagination({ \n  pageSizeOptions = [10, 20, 50, 100] \n}: DataGridPaginationProps) {\n  const { table } = useDataGrid();\n\n  const currentPage = table.getState().pagination.pageIndex + 1;\n  const totalPages = table.getPageCount();\n  const pageSize = table.getState().pagination.pageSize;\n\n  // Support both client-side and server-side pagination\n  const isServerSide = table.options.manualPagination;\n  const totalCount = (table.options.meta as any)?.totalCount;\n  const totalRows = isServerSide && totalCount ? totalCount : table.getFilteredRowModel().rows.length;\n  const startRow = table.getState().pagination.pageIndex * pageSize + 1;\n  const endRow = Math.min(startRow + pageSize - 1, totalRows);\n\n  return (\n    <div className='flex items-center justify-between px-2'>\n      <div className='flex-1 text-sm text-muted-foreground'>\n        {table.getFilteredSelectedRowModel().rows.length > 0 && (\n          <span>\n            {table.getFilteredSelectedRowModel().rows.length} of {table.getFilteredRowModel().rows.length} row(s)\n            selected.\n          </span>\n        )}\n      </div>\n\n      <div className='flex items-center space-x-6 lg:space-x-8'>\n        {/* Rows per page */}\n        <div className='flex items-center space-x-2'>\n          <p className='text-sm font-medium'>Rows per page</p>\n          <Select\n            value={pageSize.toString()}\n            onValueChange={(value) => {\n              table.setPageSize(Number(value));\n            }}>\n            <SelectTrigger className='h-8 w-[70px]'>\n              <SelectValue placeholder={pageSize.toString()} />\n            </SelectTrigger>\n            <SelectContent side='top'>\n              {pageSizeOptions.map((size) => (\n                <SelectItem key={size} value={size.toString()}>\n                  {size}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n\n        {/* Page info */}\n        <div className='flex w-[100px] items-center justify-center text-sm font-medium'>\n          Page {currentPage} of {totalPages}\n        </div>\n\n        {/* Row range info */}\n        <div className='text-sm text-muted-foreground'>\n          {totalRows > 0 ? `${startRow}-${endRow} of ${totalRows}` : '0 of 0'}\n        </div>\n\n        {/* Navigation buttons */}\n        <div className='flex items-center space-x-2'>\n          <Button\n            variant='outline'\n            className='hidden h-8 w-8 p-0 lg:flex'\n            onClick={() => table.setPageIndex(0)}\n            disabled={!table.getCanPreviousPage()}\n            aria-label='Go to first page'>\n            <ChevronsLeft className='h-4 w-4' />\n          </Button>\n\n          <Button\n            variant='outline'\n            className='h-8 w-8 p-0'\n            onClick={() => table.previousPage()}\n            disabled={!table.getCanPreviousPage()}\n            aria-label='Go to previous page'>\n            <ChevronLeft className='h-4 w-4' />\n          </Button>\n\n          <Button\n            variant='outline'\n            className='h-8 w-8 p-0'\n            onClick={() => table.nextPage()}\n            disabled={!table.getCanNextPage()}\n            aria-label='Go to next page'>\n            <ChevronRight className='h-4 w-4' />\n          </Button>\n\n          <Button\n            variant='outline'\n            className='hidden h-8 w-8 p-0 lg:flex'\n            onClick={() => table.setPageIndex(table.getPageCount() - 1)}\n            disabled={!table.getCanNextPage()}\n            aria-label='Go to last page'>\n            <ChevronsRight className='h-4 w-4' />\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/data-grid-filters.tsx",
      "content": "import { Search, Settings2, Eye, EyeOff } from 'lucide-react'\nimport { Input } from '../ui/input';\nimport { Button } from '../ui/button';\nimport {\n  DropdownMenu,\n  DropdownMenuCheckboxItem,\n  DropdownMenuContent,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuTrigger,\n} from '../ui/dropdown-menu';\nimport { useDataGrid } from './context'\n\ninterface DataGridFiltersProps {\n  enableGlobalFilter?: boolean\n  enableColumnFilters?: boolean\n  globalFilter: string\n  onGlobalFilterChange: (value: string) => void\n}\n\nexport function DataGridFilters({\n  enableGlobalFilter = true,\n  enableColumnFilters = true,\n  globalFilter,\n  onGlobalFilterChange,\n}: DataGridFiltersProps) {\n  const { table } = useDataGrid()\n\n  return (\n    <div className=\"flex items-center justify-between\">\n      <div className=\"flex flex-1 items-center space-x-2\">\n        {/* Global Search */}\n        {enableGlobalFilter && (\n          <div className=\"relative max-w-sm\">\n            <Search className=\"absolute left-2 top-2.5 h-4 w-4 text-muted-foreground\" />\n            <Input\n              placeholder=\"Search all columns...\"\n              value={globalFilter}\n              onChange={(event) => onGlobalFilterChange(event.target.value)}\n              className=\"pl-8\"\n              aria-label=\"Search all columns\"\n            />\n          </div>\n        )}\n      </div>\n\n      <div className=\"flex items-center space-x-2\">\n        {/* Column Visibility Toggle */}\n        <DropdownMenu>\n          <DropdownMenuTrigger asChild>\n            <Button \n              variant=\"outline\" \n              size=\"sm\" \n              className=\"ml-auto hidden h-8 lg:flex\"\n              aria-label=\"Toggle column visibility\"\n            >\n              <Settings2 className=\"mr-2 h-4 w-4\" />\n              View\n            </Button>\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"end\" className=\"w-[150px]\">\n            <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>\n            <DropdownMenuSeparator />\n            {table\n              .getAllColumns()\n              .filter(\n                (column) =>\n                  typeof column.accessorFn !== 'undefined' && column.getCanHide()\n              )\n              .map((column) => {\n                const isVisible = column.getIsVisible()\n                return (\n                  <DropdownMenuCheckboxItem\n                    key={column.id}\n                    className=\"capitalize\"\n                    checked={isVisible}\n                    onCheckedChange={(value) => column.toggleVisibility(!!value)}\n                  >\n                    <div className=\"flex items-center space-x-2\">\n                      {isVisible ? (\n                        <Eye className=\"h-4 w-4\" />\n                      ) : (\n                        <EyeOff className=\"h-4 w-4\" />\n                      )}\n                      <span>\n                        {typeof column.columnDef.header === 'string'\n                          ? column.columnDef.header\n                          : column.id}\n                      </span>\n                    </div>\n                  </DropdownMenuCheckboxItem>\n                )\n              })}\n          </DropdownMenuContent>\n        </DropdownMenu>\n      </div>\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/data-grid-action-dock.tsx",
      "content": "import { X, MoreHorizontal } from 'lucide-react';\nimport { Button } from '../ui/button';\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '../ui/dropdown-menu';\nimport { useDataGrid } from './context';\nimport { DataGridAction } from './types';\n\nexport function DataGridActionDock() {\n  const { selectedRows, actions, table } = useDataGrid();\n\n  if (selectedRows.length === 0 || actions.length === 0) {\n    return null;\n  }\n\n  // Filter actions based on visibility and enablement\n  const visibleActions = actions.filter((action) => (action.isVisible ? action.isVisible(selectedRows) : true));\n\n  const primaryActions = visibleActions.slice(0, 3); // Show first 3 actions as dock items\n  const overflowActions = visibleActions.slice(3); // Rest go in dropdown\n\n  const handleActionClick = async (action: DataGridAction<any>) => {\n    try {\n      await action.onClick(selectedRows);\n    } catch (error) {\n      console.error('Action failed:', error);\n    }\n  };\n\n  const clearSelection = () => {\n    table.resetRowSelection();\n  };\n\n  return (\n    <div className='fixed bottom-4 left-1/2 -translate-x-1/2 z-50'>\n      <div className='flex items-center gap-2 px-3 py-2 bg-background border border-border rounded-md shadow-md'>\n        <Button variant='ghost' size='sm' onClick={clearSelection} aria-label='Clear selection' className='h-8 px-2'>\n          {selectedRows.length} selected <X className='h-3 w-3 ml-1' />\n        </Button>\n\n        {/* Dock Separator */}\n        <div className='w-px h-4 bg-border' />\n\n        {/* Primary Actions */}\n        <div className='flex items-center gap-1'>\n          {primaryActions.map((action) => {\n            const isEnabled = action.isEnabled ? action.isEnabled(selectedRows) : true;\n\n            return (\n              <Button\n                key={action.id}\n                variant={action.variant || 'default'}\n                size='sm'\n                onClick={() => handleActionClick(action)}\n                disabled={!isEnabled}\n                className='h-8 px-3'>\n                {action.icon && <span className='h-3 w-3 mr-1'>{action.icon}</span>}\n                <span className='text-xs'>{action.label}</span>\n              </Button>\n            );\n          })}\n        </div>\n\n        {/* Overflow Actions */}\n        {overflowActions.length > 0 && (\n          <>\n            <div className='w-px h-4 bg-border' />\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button variant='ghost' size='sm' className='h-8 px-2'>\n                  <MoreHorizontal className='h-3 w-3 mr-1' />\n                  <span className='text-xs'>More</span>\n                </Button>\n              </DropdownMenuTrigger>\n              <DropdownMenuContent align='center' side='top' sideOffset={4}>\n                {overflowActions.map((action) => {\n                  const isEnabled = action.isEnabled ? action.isEnabled(selectedRows) : true;\n\n                  return (\n                    <DropdownMenuItem key={action.id} onClick={() => handleActionClick(action)} disabled={!isEnabled}>\n                      {action.icon && <span className='h-3 w-3 mr-2'>{action.icon}</span>}\n                      <span className='text-xs'>{action.label}</span>\n                    </DropdownMenuItem>\n                  );\n                })}\n              </DropdownMenuContent>\n            </DropdownMenu>\n          </>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/data-grid-context-menu.tsx",
      "content": "import { ReactNode } from 'react';\nimport {\n  ContextMenu,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuSeparator,\n  ContextMenuTrigger,\n} from '../ui/context-menu';\nimport { Row, Column } from '@tanstack/react-table';\nimport { CellContextMenuItem, HeaderContextMenuItem } from './types';\n\ninterface CellContextMenuProps<TData> {\n  children: ReactNode;\n  row: Row<TData>;\n  column: Column<TData>;\n  value: any;\n  items?: CellContextMenuItem<TData>[];\n}\n\ninterface HeaderContextMenuProps<TData> {\n  children: ReactNode;\n  column: Column<TData>;\n  items?: HeaderContextMenuItem<TData>[];\n}\n\nexport function CellContextMenu<TData>({ children, row, column, value, items = [] }: CellContextMenuProps<TData>) {\n  if (items.length === 0) {\n    return <>{children}</>;\n  }\n\n  const visibleItems = items.filter((item) => (item.isVisible ? item.isVisible(row, column, value) : true));\n\n  if (visibleItems.length === 0) {\n    return <>{children}</>;\n  }\n\n  return (\n    <ContextMenu>\n      <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>\n      <ContextMenuContent className='w-48'>\n        {visibleItems.map((item) => {\n          if (item.separator) {\n            return <ContextMenuSeparator key={item.id} />;\n          }\n\n          const isEnabled = item.isEnabled ? item.isEnabled(row, column, value) : true;\n\n          return (\n            <ContextMenuItem\n              key={item.id}\n              onClick={() => item.onClick(row, column, value)}\n              disabled={!isEnabled}\n              className={`flex items-center gap-2 ${\n                item.variant === 'destructive' ? 'text-destructive focus:text-destructive' : ''\n              }`}>\n              {item.icon && <span className='h-4 w-4'>{item.icon}</span>}\n              <span>{item.label}</span>\n            </ContextMenuItem>\n          );\n        })}\n      </ContextMenuContent>\n    </ContextMenu>\n  );\n}\n\nexport function HeaderContextMenu<TData>({ children, column, items = [] }: HeaderContextMenuProps<TData>) {\n  if (items.length === 0) {\n    return <>{children}</>;\n  }\n\n  const visibleItems = items.filter((item) => (item.isVisible ? item.isVisible(column) : true));\n\n  if (visibleItems.length === 0) {\n    return <>{children}</>;\n  }\n\n  return (\n    <ContextMenu>\n      <ContextMenuTrigger asChild>{children}</ContextMenuTrigger>\n      <ContextMenuContent className='w-48'>\n        {visibleItems.map((item) => {\n          if (item.separator) {\n            return <ContextMenuSeparator key={item.id} />;\n          }\n\n          const isEnabled = item.isEnabled ? item.isEnabled(column) : true;\n\n          return (\n            <ContextMenuItem\n              key={item.id}\n              onClick={() => item.onClick(column)}\n              disabled={!isEnabled}\n              className={`flex items-center gap-2 ${\n                item.variant === 'destructive' ? 'text-destructive focus:text-destructive' : ''\n              }`}>\n              {item.icon && <span className='h-4 w-4'>{item.icon}</span>}\n              <span>{item.label}</span>\n            </ContextMenuItem>\n          );\n        })}\n      </ContextMenuContent>\n    </ContextMenu>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/data-grid-editable-cell.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Row, Column } from '@tanstack/react-table';\nimport { Input } from '../ui/input';\nimport { Button } from '../ui/button';\nimport { Check, X } from 'lucide-react';\nimport { cn } from '../../lib/utils';\nimport { CellEditConfig, CellEditComponentProps, EditBehaviors } from './types';\nimport { useDataGrid } from './context';\n\ninterface EditableCellProps<TData> {\n  row: Row<TData>;\n  column: Column<TData>;\n  value: any;\n  editConfig: CellEditConfig<TData>;\n}\n\n// Default input component for text editing with full control\nexport function DefaultTextInput<TData>({\n  value,\n  onChange,\n  onSave,\n  onCancel,\n  config,\n  isSaving,\n  error,\n  placeholder,\n  disabled,\n  autoFocus = true,\n  selectAllOnFocus = true,\n}: CellEditComponentProps<TData, string>) {\n  const [inputValue, setInputValue] = useState(String(value || ''));\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const behavior = config.behavior || EditBehaviors.clickToEdit;\n\n  useEffect(() => {\n    if (autoFocus && inputRef.current) {\n      inputRef.current.focus();\n      if (selectAllOnFocus) {\n        inputRef.current.select();\n      }\n    }\n  }, [autoFocus, selectAllOnFocus]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && behavior.saveOn?.includes('enter')) {\n      e.preventDefault();\n      onChange(inputValue);\n      onSave();\n    } else if (e.key === 'Escape' && behavior.cancelOn?.includes('escape')) {\n      e.preventDefault();\n      onCancel();\n    }\n  };\n\n  const handleBlur = () => {\n    if (behavior.saveOn?.includes('blur')) {\n      onChange(inputValue);\n      onSave();\n    }\n  };\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value;\n    setInputValue(newValue);\n    onChange(newValue);\n  };\n\n  return (\n    <div className='w-full relative'>\n      {/* Input positioned at top of cell */}\n      <div className='absolute top-0 left-0 right-0 z-20'>\n        <Input\n          ref={inputRef}\n          value={inputValue}\n          onChange={handleChange}\n          onKeyDown={handleKeyDown}\n          onBlur={handleBlur}\n          placeholder={placeholder}\n          disabled={disabled || isSaving}\n          className={cn(\n            'h-8 text-sm border-primary shadow-md',\n            error && 'border-destructive',\n            isSaving && 'opacity-50'\n          )}\n          autoFocus={autoFocus}\n        />\n      </div>\n\n      {/* Action buttons positioned at top-right or bottom-right */}\n      {behavior.showActionButtons && (\n        <div\n          className={`absolute ${\n            behavior.buttonPosition === 'bottom-right' ? 'top-9 right-0' : 'top-0 right-0'\n          } z-30 bg-background border border-border rounded-md shadow-lg p-1 flex items-center gap-1`}>\n          <Button\n            size='sm'\n            variant='ghost'\n            className='h-7 w-7 p-0'\n            onClick={() => {\n              onChange(inputValue);\n              onSave();\n            }}\n            disabled={isSaving}>\n            <Check className='h-3 w-3' />\n          </Button>\n          <Button size='sm' variant='ghost' className='h-7 w-7 p-0' onClick={onCancel} disabled={isSaving}>\n            <X className='h-3 w-3' />\n          </Button>\n        </div>\n      )}\n\n      {/* Error message positioned below input */}\n      {error && (\n        <div className='absolute top-9 left-0 right-0 z-30 p-2 text-xs text-destructive bg-destructive/10 border border-destructive/20 rounded-md shadow-lg'>\n          {error}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Editable cell wrapper component with full developer control\nexport function EditableCell<TData>({\n  row,\n  column,\n  value,\n  editConfig\n}: EditableCellProps<TData>) {\n  const { editingCell, setEditingCell, onCellEdit, onCellEditError, defaultEditMode } = useDataGrid<TData>();\n  const [currentValue, setCurrentValue] = useState(value);\n  const [error, setError] = useState<string | null>(null);\n  const [isSaving, setIsSaving] = useState(false);\n\n  // Get behavior configuration with defaults\n  const behavior = editConfig.behavior || EditBehaviors.clickToEdit;\n  const mode = behavior.mode || defaultEditMode;\n\n  const isCurrentlyEditing = editingCell?.rowId === row.id && editingCell?.columnId === column.id;\n  const isEditing = isCurrentlyEditing;\n\n  useEffect(() => {\n    setCurrentValue(value);\n  }, [value]);\n\n  // Callbacks for the input component\n  const handleChange = useCallback((newValue: any) => {\n    setCurrentValue(newValue);\n  }, []);\n\n  const handleSave = useCallback(async () => {\n    if (isSaving) return;\n\n    // Validate the value\n    if (editConfig.validate) {\n      const validationError = editConfig.validate(currentValue, row);\n      if (validationError) {\n        setError(validationError);\n        return;\n      }\n    }\n\n    setIsSaving(true);\n    setError(null);\n\n    try {\n      // Call edit start callback\n      editConfig.onEditStart?.(row, column);\n\n      // Try column-specific onSave first, then global onCellEdit\n      const saveHandler = editConfig.onSave || onCellEdit;\n\n      if (saveHandler) {\n        const success = await saveHandler(currentValue, row, column);\n        if (!success) {\n          setError('Failed to save changes');\n          setIsSaving(false);\n          return;\n        }\n      }\n\n      // Update the row data optimistically\n      const originalData = row.original as any;\n      const accessorKey = (column as any).accessorKey;\n      if (accessorKey) {\n        originalData[accessorKey] = currentValue;\n      }\n\n      // Exit edit mode\n      setEditingCell(null);\n\n      // Call edit end callback\n      editConfig.onEditEnd?.(row, column);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to save changes';\n      setError(errorMessage);\n      onCellEditError?.(errorMessage, row, column);\n    } finally {\n      setIsSaving(false);\n    }\n  }, [currentValue, editConfig, row, column, onCellEdit, onCellEditError, isSaving, mode, setEditingCell]);\n\n  const handleCancel = useCallback(() => {\n    setCurrentValue(value); // Reset to original value\n    setError(null);\n    editConfig.onCancel?.(row, column);\n\n    // Exit edit mode\n    setEditingCell(null);\n  }, [value, editConfig, row, column, mode, setEditingCell]);\n\n  const handleExit = useCallback(() => {\n    // Exit without saving or canceling\n    setEditingCell(null);\n    setError(null);\n  }, [setEditingCell]);\n\n  const startEditing = useCallback(() => {\n    if (editConfig.disabled?.(row)) return;\n\n    setEditingCell({ rowId: row.id, columnId: column.id });\n    setError(null);\n    editConfig.onEditStart?.(row, column);\n  }, [editConfig, row, column, setEditingCell]);\n\n  const handleClick = useCallback(() => {\n    if (mode === 'click' && !isEditing) {\n      startEditing();\n    }\n  }, [mode, isEditing, startEditing]);\n\n  const handleDoubleClick = useCallback(() => {\n    if (mode === 'doubleClick' && !isEditing) {\n      startEditing();\n    }\n  }, [mode, isEditing, startEditing]);\n\n  // Render edit component\n  if (isEditing) {\n    const EditComponent = editConfig.component || DefaultTextInput;\n\n    return (\n      <div className='relative w-full h-full min-h-[32px]'>\n        <EditComponent\n          value={currentValue}\n          onChange={handleChange}\n          onSave={handleSave}\n          onCancel={handleCancel}\n          onExit={handleExit}\n          row={row}\n          column={column}\n          config={editConfig}\n          isSaving={isSaving}\n          error={error}\n          placeholder={editConfig.placeholder}\n          disabled={editConfig.disabled?.(row)}\n          autoFocus={behavior.autoFocus}\n          selectAllOnFocus={behavior.selectAllOnFocus}\n        />\n      </div>\n    );\n  }\n\n  // Render display value\n  return (\n    <div\n      className={cn(\n        \"w-full h-full flex items-center\",\n        mode === 'click' && \"cursor-pointer hover:bg-muted/50\",\n        mode === 'doubleClick' && \"cursor-pointer hover:bg-muted/50\",\n        editConfig.disabled?.(row) && \"opacity-50 cursor-not-allowed\"\n      )}\n      onClick={handleClick}\n      onDoubleClick={handleDoubleClick}\n      title={\n        mode === 'click' ? 'Click to edit' :\n        mode === 'doubleClick' ? 'Double-click to edit' :\n        undefined\n      }\n    >\n      {String(currentValue || '')}\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/context.tsx",
      "content": "import { createContext, useContext } from 'react'\nimport { DataGridContextValue } from './types'\n\nexport const DataGridContext = createContext<DataGridContextValue<any> | null>(null)\n\nexport function useDataGrid<TData>() {\n  const context = useContext(DataGridContext) as DataGridContextValue<TData> | null\n  \n  if (!context) {\n    throw new Error('useDataGrid must be used within a DataGrid component')\n  }\n  \n  return context\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/types.ts",
      "content": "import { ColumnDef, Row, Table, Column } from '@tanstack/react-table';\nimport { ReactNode, ComponentType } from 'react';\n\n// Cell editing types\nexport type CellEditMode = 'click' | 'doubleClick';\n\nexport type CellEditTrigger = 'blur' | 'enter' | 'escape' | 'manual';\n\nexport interface CellEditBehavior {\n  /** How to trigger edit mode */\n  mode?: CellEditMode;\n  /** When to save changes */\n  saveOn?: CellEditTrigger[];\n  /** When to cancel changes */\n  cancelOn?: CellEditTrigger[];\n  /** Show save/cancel buttons */\n  showActionButtons?: boolean;\n  /** Position of action buttons when shown */\n  buttonPosition?: 'top-right' | 'bottom-right';\n  /** Auto-save on blur (legacy support) */\n  autoSave?: boolean;\n  /** Auto-focus input when editing starts */\n  autoFocus?: boolean;\n  /** Select all text when editing starts */\n  selectAllOnFocus?: boolean;\n}\n\nexport interface CellEditConfig<TData, TValue = any> {\n  enabled: boolean;\n  behavior?: CellEditBehavior;\n  component?: ComponentType<CellEditComponentProps<TData, TValue>>;\n  validate?: (value: TValue, row: Row<TData>) => string | null;\n  onSave?: (value: TValue, row: Row<TData>, column: Column<TData>) => Promise<boolean> | boolean;\n  onCancel?: (row: Row<TData>, column: Column<TData>) => void;\n  onEditStart?: (row: Row<TData>, column: Column<TData>) => void;\n  onEditEnd?: (row: Row<TData>, column: Column<TData>) => void;\n  placeholder?: string;\n  disabled?: (row: Row<TData>) => boolean;\n}\n\nexport interface CellEditComponentProps<TData, TValue = any> {\n  /** Current cell value */\n  value: TValue;\n  /** Update the current value (doesn't save automatically) */\n  onChange: (value: TValue) => void;\n  /** Manually trigger save */\n  onSave: () => void;\n  /** Manually trigger cancel */\n  onCancel: () => void;\n  /** Exit edit mode without saving or canceling */\n  onExit: () => void;\n  /** Row data */\n  row: Row<TData>;\n  /** Column definition */\n  column: Column<TData>;\n  /** Edit configuration */\n  config: CellEditConfig<TData, TValue>;\n  /** Whether the cell is currently saving */\n  isSaving: boolean;\n  /** Current validation error, if any */\n  error: string | null;\n  /** Placeholder text */\n  placeholder?: string;\n  /** Whether the input is disabled */\n  disabled?: boolean;\n  /** Whether to auto-focus (from config) */\n  autoFocus?: boolean;\n  /** Whether to select all text on focus (from config) */\n  selectAllOnFocus?: boolean;\n}\n\n// Utility types for common edit configurations\nexport interface QuickEditConfig<TData, TValue = any> {\n  /** Input component to use */\n  component?: ComponentType<CellEditComponentProps<TData, TValue>>;\n  /** Validation function */\n  validate?: (value: TValue, row: Row<TData>) => string | null;\n  /** Save handler */\n  onSave?: (value: TValue, row: Row<TData>, column: Column<TData>) => Promise<boolean> | boolean;\n  /** Placeholder text */\n  placeholder?: string;\n  /** Disable editing for certain rows */\n  disabled?: (row: Row<TData>) => boolean;\n}\n\n// Pre-configured edit behaviors\nexport const EditBehaviors = {\n  /** Click to edit, save on blur or Enter, cancel on Escape */\n  clickToEdit: {\n    mode: 'click' as CellEditMode,\n    saveOn: ['blur', 'enter'] as CellEditTrigger[],\n    cancelOn: ['escape'] as CellEditTrigger[],\n    showActionButtons: false,\n    autoFocus: true,\n    selectAllOnFocus: true,\n  },\n  /** Click to edit with explicit save/cancel buttons */\n  clickWithButtons: {\n    mode: 'click' as CellEditMode,\n    saveOn: ['manual'] as CellEditTrigger[],\n    cancelOn: ['manual'] as CellEditTrigger[],\n    showActionButtons: true,\n    buttonPosition: 'top-right' as const,\n    autoFocus: true,\n    selectAllOnFocus: true,\n  },\n  /** Double-click to edit, save on blur */\n  doubleClickToEdit: {\n    mode: 'doubleClick' as CellEditMode,\n    saveOn: ['blur', 'enter'] as CellEditTrigger[],\n    cancelOn: ['escape'] as CellEditTrigger[],\n    showActionButtons: false,\n    autoFocus: true,\n    selectAllOnFocus: true,\n  },\n} as const;\n\nexport interface DataGridColumn<TData> {\n  id: string;\n  header: string | ReactNode;\n  accessorKey?: keyof TData;\n  cell?: ({ row }: { row: Row<TData> }) => ReactNode;\n  enableSorting?: boolean;\n  enableFiltering?: boolean;\n  enableHiding?: boolean;\n  enableResizing?: boolean;\n  enableEditing?: boolean | CellEditConfig<TData>;\n  size?: number;\n  minSize?: number;\n  maxSize?: number;\n  // Allow any other ColumnDef properties\n  [key: string]: any;\n}\n\nexport interface DataGridAction<TData> {\n  id: string;\n  label: string;\n  icon?: ReactNode;\n  variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';\n  onClick: (selectedRows: Row<TData>[]) => void | Promise<void>;\n  isEnabled?: (selectedRows: Row<TData>[]) => boolean;\n  isVisible?: (selectedRows: Row<TData>[]) => boolean;\n}\n\nexport interface CellContextMenuItem<TData> {\n  id: string;\n  label: string;\n  icon?: ReactNode;\n  onClick: (row: Row<TData>, column: Column<TData>, value: any) => void | Promise<void>;\n  isEnabled?: (row: Row<TData>, column: Column<TData>, value: any) => boolean;\n  isVisible?: (row: Row<TData>, column: Column<TData>, value: any) => boolean;\n  separator?: boolean;\n  variant?: 'default' | 'destructive';\n}\n\nexport interface HeaderContextMenuItem<TData> {\n  id: string;\n  label: string;\n  icon?: ReactNode;\n  onClick: (column: Column<TData>) => void | Promise<void>;\n  isEnabled?: (column: Column<TData>) => boolean;\n  isVisible?: (column: Column<TData>) => boolean;\n  separator?: boolean;\n  variant?: 'default' | 'destructive';\n}\n\nexport interface DataChangeParams {\n  pagination: {\n    pageIndex: number;\n    pageSize: number;\n  };\n  sorting: Array<{\n    id: string;\n    desc: boolean;\n  }>;\n  filters: Array<{\n    id: string;\n    value: any;\n  }>;\n  globalFilter: string;\n}\n\nexport interface DataGridProps<TData> {\n  data: TData[];\n  columns: DataGridColumn<TData>[];\n\n  // Selection\n  enableRowSelection?: boolean;\n  enableMultiRowSelection?: boolean;\n  onRowSelectionChange?: (selectedRows: Row<TData>[]) => void;\n\n  // Actions\n  actions?: DataGridAction<TData>[];\n\n  // Context Menus\n  cellContextMenuItems?: CellContextMenuItem<TData>[];\n  headerContextMenuItems?: HeaderContextMenuItem<TData>[];\n  enableCellContextMenu?: boolean;\n  enableHeaderContextMenu?: boolean;\n\n  // Pagination\n  enablePagination?: boolean;\n  pageSize?: number;\n  pageSizeOptions?: number[];\n  manualPagination?: boolean;\n  pageCount?: number;\n  totalCount?: number;\n  onPaginationChange?: (pageIndex: number, pageSize: number) => void;\n\n  // Sorting\n  enableSorting?: boolean;\n  enableMultiSort?: boolean;\n  manualSorting?: boolean;\n  onSortingChange?: (sorting: any[]) => void;\n\n  // Filtering\n  enableGlobalFilter?: boolean;\n  enableColumnFilters?: boolean;\n  manualFiltering?: boolean;\n  onGlobalFilterChange?: (globalFilter: string) => void;\n  onColumnFiltersChange?: (columnFilters: any[]) => void;\n\n  // Server-side data loading\n  onDataChange?: (params: DataChangeParams) => void;\n\n  // Cell editing\n  enableCellEditing?: boolean;\n  defaultEditMode?: CellEditMode;\n  onCellEdit?: (value: any, row: Row<TData>, column: Column<TData>) => Promise<boolean> | boolean;\n  onCellEditError?: (error: string, row: Row<TData>, column: Column<TData>) => void;\n\n  // Column resizing\n  enableColumnResizing?: boolean;\n  onColumnSizingChange?: (columnSizing: Record<string, number>) => void;\n\n  // Virtualization\n  enableVirtualization?: boolean;\n  estimateSize?: number;\n\n  // Loading & Error states\n  isLoading?: boolean;\n  error?: string | null;\n\n  // Styling\n  className?: string;\n\n  // Accessibility\n  'aria-label'?: string;\n  'aria-describedby'?: string;\n}\n\nexport interface DataGridState {\n  rowSelection: Record<string, boolean>;\n  sorting: any[];\n  columnFilters: any[];\n  globalFilter: string;\n  pagination: {\n    pageIndex: number;\n    pageSize: number;\n  };\n  columnVisibility: Record<string, boolean>;\n  columnSizing: Record<string, number>;\n}\n\nexport interface DataGridContextValue<TData> {\n  table: Table<TData>;\n  selectedRows: Row<TData>[];\n  actions: DataGridAction<TData>[];\n  cellContextMenuItems?: CellContextMenuItem<TData>[];\n  headerContextMenuItems?: HeaderContextMenuItem<TData>[];\n  enableCellContextMenu: boolean;\n  enableHeaderContextMenu: boolean;\n  enableCellEditing: boolean;\n  defaultEditMode: CellEditMode;\n  editingCell: { rowId: string; columnId: string } | null;\n  setEditingCell: (cell: { rowId: string; columnId: string } | null) => void;\n  onCellEdit?: (value: any, row: Row<TData>, column: Column<TData>) => Promise<boolean> | boolean;\n  onCellEditError?: (error: string, row: Row<TData>, column: Column<TData>) => void;\n  isLoading: boolean;\n  error: string | null;\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/context-menu-utils.tsx",
      "content": "import {\n  Copy,\n  Pin,\n  PinOff,\n  SortAsc,\n  SortDesc,\n  Filter,\n  FilterX,\n  Eye,\n  EyeOff,\n  Trash2,\n  Edit,\n  MoreHorizontal,\n  Columns,\n} from 'lucide-react';\nimport { Column, Row } from '@tanstack/react-table';\nimport { CellContextMenuItem, HeaderContextMenuItem } from './types';\n\n// Individual Cell Context Menu Items\n\nexport const copyCellItem = <TData,>(): CellContextMenuItem<TData> => ({\n  id: 'copy-cell',\n  label: 'Copy Cell',\n  icon: <Copy className='h-4 w-4' />,\n  onClick: (row, column, value) => {\n    const textValue = String(value || '');\n    navigator.clipboard.writeText(textValue);\n  },\n});\n\nexport const copyRowItem = <TData,>(): CellContextMenuItem<TData> => ({\n  id: 'copy-row',\n  label: 'Copy Row',\n  icon: <Copy className='h-4 w-4' />,\n  onClick: (row) => {\n    const rowData = JSON.stringify(row.original, null, 2);\n    navigator.clipboard.writeText(rowData);\n  },\n});\n\nexport const editCellItem = <TData,>(\n  onEdit?: (row: Row<TData>, column: Column<TData>, value: any) => void\n): CellContextMenuItem<TData> => ({\n  id: 'edit-cell',\n  label: 'Edit Cell',\n  icon: <Edit className='h-4 w-4' />,\n  onClick:\n    onEdit ||\n    ((row, column, value) => {\n      console.log('Edit cell:', { row: row.original, column: column.id, value });\n    }),\n  isEnabled: (row, column) => column.columnDef.enableEditing !== false,\n});\n\nexport const deleteRowItem = <TData,>(onDelete?: (row: Row<TData>) => void): CellContextMenuItem<TData> => ({\n  id: 'delete-row',\n  label: 'Delete Row',\n  icon: <Trash2 className='h-4 w-4' />,\n  variant: 'destructive' as const,\n  onClick:\n    onDelete ||\n    ((row) => {\n      console.log('Delete row:', row.original);\n    }),\n});\n\nexport const selectRowItem = <TData,>(): CellContextMenuItem<TData> => ({\n  id: 'select-row',\n  label: 'Toggle Selection',\n  icon: <MoreHorizontal className='h-4 w-4' />,\n  onClick: (row) => {\n    row.toggleSelected();\n  },\n});\n\nexport const viewRowDetailsItem = <TData,>(onView?: (row: Row<TData>) => void): CellContextMenuItem<TData> => ({\n  id: 'view-details',\n  label: 'View Details',\n  icon: <Eye className='h-4 w-4' />,\n  onClick:\n    onView ||\n    ((row) => {\n      console.log('View details:', row.original);\n    }),\n});\n\n// Individual Header Context Menu Items\n\nexport const sortAscendingItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'sort-asc',\n  label: 'Sort Ascending',\n  icon: <SortAsc className='h-4 w-4' />,\n  onClick: (column) => column.toggleSorting(false),\n  isEnabled: (column) => column.getCanSort(),\n});\n\nexport const sortDescendingItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'sort-desc',\n  label: 'Sort Descending',\n  icon: <SortDesc className='h-4 w-4' />,\n  onClick: (column) => column.toggleSorting(true),\n  isEnabled: (column) => column.getCanSort(),\n});\n\nexport const clearSortItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'clear-sort',\n  label: 'Clear Sort',\n  icon: <MoreHorizontal className='h-4 w-4' />,\n  onClick: (column) => column.clearSorting(),\n  isEnabled: (column) => column.getIsSorted() !== false,\n});\n\nexport const filterColumnItem = <TData,>(onFilter?: (column: Column<TData>) => void): HeaderContextMenuItem<TData> => ({\n  id: 'filter-column',\n  label: 'Filter Column',\n  icon: <Filter className='h-4 w-4' />,\n  onClick: onFilter || ((column) => console.log('Filter column:', column.id)),\n  isEnabled: (column) => column.getCanFilter(),\n});\n\nexport const clearFilterItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'clear-filter',\n  label: 'Clear Filter',\n  icon: <FilterX className='h-4 w-4' />,\n  onClick: (column) => column.setFilterValue(undefined),\n  isEnabled: (column) => column.getFilterValue() !== undefined,\n});\n\nexport const pinLeftItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'pin-left',\n  label: 'Pin Left',\n  icon: <Pin className='h-4 w-4' />,\n  onClick: (column) => column.pin('left'),\n  isEnabled: (column) => column.getCanPin() && column.getIsPinned() !== 'left',\n});\n\nexport const pinRightItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'pin-right',\n  label: 'Pin Right',\n  icon: <Pin className='h-4 w-4' />,\n  onClick: (column) => column.pin('right'),\n  isEnabled: (column) => column.getCanPin() && column.getIsPinned() !== 'right',\n});\n\nexport const unpinColumnItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'unpin-column',\n  label: 'Unpin Column',\n  icon: <PinOff className='h-4 w-4' />,\n  onClick: (column) => column.pin(false),\n  isEnabled: (column) => column.getIsPinned() !== false,\n});\n\nexport const hideColumnItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'hide-column',\n  label: 'Hide Column',\n  icon: <EyeOff className='h-4 w-4' />,\n  onClick: (column) => column.toggleVisibility(false),\n  isEnabled: (column) => column.getCanHide(),\n});\n\nexport const showColumnItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'show-column',\n  label: 'Show Column',\n  icon: <Eye className='h-4 w-4' />,\n  onClick: (column) => column.toggleVisibility(true),\n  isEnabled: (column) => !column.getIsVisible(),\n});\n\nexport const autoResizeColumnItem = <TData,>(): HeaderContextMenuItem<TData> => ({\n  id: 'auto-resize',\n  label: 'Auto Resize',\n  icon: <Columns className='h-4 w-4' />,\n  onClick: (column) => column.resetSize(),\n  isEnabled: (column) => column.getCanResize(),\n});\n\n// Utility functions for custom context menu items\nexport const createCopyMenuItem = <TData,>(\n  id: string,\n  label: string,\n  getValue: (row: Row<TData>, column: Column<TData>, value: any) => string\n): CellContextMenuItem<TData> => ({\n  id,\n  label,\n  icon: <Copy className=\"h-4 w-4\" />,\n  onClick: (row, column, value) => {\n    const textValue = getValue(row, column, value);\n    navigator.clipboard.writeText(textValue);\n  },\n});\n\nexport const createEditMenuItem = <TData,>(\n  id: string,\n  label: string,\n  onEdit: (row: Row<TData>, column: Column<TData>, value: any) => void\n): CellContextMenuItem<TData> => ({\n  id,\n  label,\n  icon: <Edit className=\"h-4 w-4\" />,\n  onClick: onEdit,\n});\n\nexport const createDeleteMenuItem = <TData,>(\n  id: string,\n  label: string,\n  onDelete: (row: Row<TData>) => void\n): CellContextMenuItem<TData> => ({\n  id,\n  label,\n  icon: <Trash2 className=\"h-4 w-4\" />,\n  variant: 'destructive',\n  onClick: (row) => onDelete(row),\n});\n\n// Separator utilities\nexport const cellSeparator = <TData,>(id: string): CellContextMenuItem<TData> => ({\n  id,\n  label: '',\n  separator: true,\n  onClick: () => {},\n});\n\nexport const headerSeparator = <TData,>(id: string): HeaderContextMenuItem<TData> => ({\n  id,\n  label: '',\n  separator: true,\n  onClick: () => {},\n});\n\n// Convenience bundles for common use cases (optional)\nexport const commonCellItems = <TData,>() => [\n  copyCellItem<TData>(),\n  copyRowItem<TData>(),\n  cellSeparator<TData>('sep-1'),\n  selectRowItem<TData>(),\n];\n\nexport const commonHeaderItems = <TData,>() => [\n  sortAscendingItem<TData>(),\n  sortDescendingItem<TData>(),\n  clearSortItem<TData>(),\n  headerSeparator<TData>('sep-1'),\n  filterColumnItem<TData>(),\n  clearFilterItem<TData>(),\n  headerSeparator<TData>('sep-2'),\n  pinLeftItem<TData>(),\n  pinRightItem<TData>(),\n  unpinColumnItem<TData>(),\n  headerSeparator<TData>('sep-3'),\n  hideColumnItem<TData>(),\n  autoResizeColumnItem<TData>(),\n];\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/edit-components.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Input } from '../ui/input';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';\nimport { Checkbox } from '../ui/checkbox';\nimport { Button } from '../ui/button';\nimport { Check, X } from 'lucide-react';\nimport { cn } from '../../lib/utils';\nimport { CellEditComponentProps, EditBehaviors } from './types';\n\n// Text Input Component with flexible behavior\nexport function TextEditInput<TData>({\n  value,\n  onChange,\n  onSave,\n  onCancel,\n  onExit,\n  config,\n  isSaving,\n  error,\n  placeholder,\n  disabled,\n  autoFocus = true,\n  selectAllOnFocus = true,\n}: CellEditComponentProps<TData, string>) {\n  const [inputValue, setInputValue] = useState(String(value || ''));\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const behavior = config.behavior || EditBehaviors.clickToEdit;\n\n  useEffect(() => {\n    if (autoFocus && inputRef.current) {\n      inputRef.current.focus();\n      if (selectAllOnFocus) {\n        inputRef.current.select();\n      }\n    }\n  }, [autoFocus, selectAllOnFocus]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && behavior.saveOn?.includes('enter')) {\n      e.preventDefault();\n      onChange(inputValue);\n      onSave();\n    } else if (e.key === 'Escape' && behavior.cancelOn?.includes('escape')) {\n      e.preventDefault();\n      onCancel();\n    }\n  };\n\n  const handleBlur = () => {\n    if (behavior.saveOn?.includes('blur')) {\n      onChange(inputValue);\n      onSave();\n    }\n  };\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value;\n    setInputValue(newValue);\n    onChange(newValue);\n\n    if (behavior.saveOn?.includes('immediate')) {\n      onSave();\n    }\n  };\n\n  return (\n    <div className=\"flex items-center gap-1 w-full relative\">\n      <Input\n        ref={inputRef}\n        value={inputValue}\n        onChange={handleChange}\n        onKeyDown={handleKeyDown}\n        onBlur={handleBlur}\n        placeholder={placeholder}\n        disabled={disabled || isSaving}\n        className={cn(\n          \"h-8 text-sm border-primary\",\n          error && \"border-destructive\",\n          isSaving && \"opacity-50\"\n        )}\n        autoFocus={autoFocus}\n      />\n\n      {behavior.showActionButtons && (\n        <div className=\"flex items-center gap-1 ml-1\">\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            className=\"h-6 w-6 p-0\"\n            onClick={() => {\n              onChange(inputValue);\n              onSave();\n            }}\n            disabled={isSaving}\n          >\n            <Check className=\"h-3 w-3\" />\n          </Button>\n          <Button\n            size=\"sm\"\n            variant=\"ghost\"\n            className=\"h-6 w-6 p-0\"\n            onClick={onCancel}\n            disabled={isSaving}\n          >\n            <X className=\"h-3 w-3\" />\n          </Button>\n        </div>\n      )}\n\n      {error && (\n        <div className=\"absolute top-full left-0 z-10 mt-1 p-2 text-xs text-destructive bg-destructive/10 border border-destructive/20 rounded\">\n          {error}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Number Input Component\nexport function NumberEditInput<TData>({\n  value,\n  onChange,\n  onSave,\n  onCancel,\n  placeholder,\n  disabled,\n  autoFocus = true,\n}: CellEditComponentProps<TData, number>) {\n  const [inputValue, setInputValue] = useState(String(value || ''));\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (autoFocus && inputRef.current) {\n      inputRef.current.focus();\n      inputRef.current.select();\n    }\n  }, [autoFocus]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      const numValue = parseFloat(inputValue);\n      onChange(isNaN(numValue) ? 0 : numValue);\n      onSave();\n    } else if (e.key === 'Escape') {\n      e.preventDefault();\n      onCancel();\n    }\n  };\n\n  const handleBlur = () => {\n    const numValue = parseFloat(inputValue);\n    onChange(isNaN(numValue) ? 0 : numValue);\n    onSave();\n  };\n\n  return (\n    <Input\n      ref={inputRef}\n      type=\"number\"\n      value={inputValue}\n      onChange={(e) => setInputValue(e.target.value)}\n      onKeyDown={handleKeyDown}\n      onBlur={handleBlur}\n      placeholder={placeholder}\n      disabled={disabled}\n      className=\"h-8 text-sm border-primary\"\n      autoFocus={autoFocus}\n    />\n  );\n}\n\n// Select/Dropdown Component\ninterface SelectOption {\n  value: string;\n  label: string;\n}\n\ninterface SelectEditInputProps<TData> extends CellEditComponentProps<TData, string> {\n  options: SelectOption[];\n}\n\nexport function SelectEditInput<TData>({\n  value,\n  onChange,\n  onSave,\n  onCancel,\n  placeholder,\n  disabled,\n  options,\n}: SelectEditInputProps<TData>) {\n  const [isOpen, setIsOpen] = useState(true);\n\n  const handleValueChange = (newValue: string) => {\n    onChange(newValue);\n    onSave();\n    setIsOpen(false);\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Escape') {\n      e.preventDefault();\n      onCancel();\n      setIsOpen(false);\n    }\n  };\n\n  return (\n    <Select\n      value={value || ''}\n      onValueChange={handleValueChange}\n      open={isOpen}\n      onOpenChange={setIsOpen}\n      disabled={disabled}\n    >\n      <SelectTrigger \n        className=\"h-8 text-sm border-primary\"\n        onKeyDown={handleKeyDown}\n        autoFocus\n      >\n        <SelectValue placeholder={placeholder} />\n      </SelectTrigger>\n      <SelectContent>\n        {options.map((option) => (\n          <SelectItem key={option.value} value={option.value}>\n            {option.label}\n          </SelectItem>\n        ))}\n      </SelectContent>\n    </Select>\n  );\n}\n\n// Checkbox Component\nexport function CheckboxEditInput<TData>({\n  value,\n  onChange,\n  onSave,\n  disabled,\n}: CellEditComponentProps<TData, boolean>) {\n  const handleCheckedChange = (checked: boolean) => {\n    onChange(checked);\n    onSave();\n  };\n\n  return (\n    <div className=\"flex items-center justify-center h-8\">\n      <Checkbox\n        checked={Boolean(value)}\n        onCheckedChange={handleCheckedChange}\n        disabled={disabled}\n        className=\"border-primary\"\n      />\n    </div>\n  );\n}\n\n// Date Input Component\nexport function DateEditInput<TData>({\n  value,\n  onChange,\n  onSave,\n  onCancel,\n  placeholder,\n  disabled,\n  autoFocus = true,\n}: CellEditComponentProps<TData, string>) {\n  const [inputValue, setInputValue] = useState(value || '');\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (autoFocus && inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, [autoFocus]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      onChange(inputValue);\n      onSave();\n    } else if (e.key === 'Escape') {\n      e.preventDefault();\n      onCancel();\n    }\n  };\n\n  const handleBlur = () => {\n    onChange(inputValue);\n    onSave();\n  };\n\n  return (\n    <Input\n      ref={inputRef}\n      type=\"date\"\n      value={inputValue}\n      onChange={(e) => setInputValue(e.target.value)}\n      onKeyDown={handleKeyDown}\n      onBlur={handleBlur}\n      placeholder={placeholder}\n      disabled={disabled}\n      className=\"h-8 text-sm border-primary\"\n      autoFocus={autoFocus}\n    />\n  );\n}\n\n// Email Input Component\nexport function EmailEditInput<TData>({\n  value,\n  onChange,\n  onSave,\n  onCancel,\n  placeholder,\n  disabled,\n  autoFocus = true,\n}: CellEditComponentProps<TData, string>) {\n  const [inputValue, setInputValue] = useState(String(value || ''));\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (autoFocus && inputRef.current) {\n      inputRef.current.focus();\n      inputRef.current.select();\n    }\n  }, [autoFocus]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      onChange(inputValue);\n      onSave();\n    } else if (e.key === 'Escape') {\n      e.preventDefault();\n      onCancel();\n    }\n  };\n\n  const handleBlur = () => {\n    onChange(inputValue);\n    onSave();\n  };\n\n  return (\n    <Input\n      ref={inputRef}\n      type=\"email\"\n      value={inputValue}\n      onChange={(e) => setInputValue(e.target.value)}\n      onKeyDown={handleKeyDown}\n      onBlur={handleBlur}\n      placeholder={placeholder}\n      disabled={disabled}\n      className=\"h-8 text-sm border-primary\"\n      autoFocus={autoFocus}\n    />\n  );\n}\n\n// Utility function to create a select component with predefined options\nexport function createSelectEditComponent<TData>(options: SelectOption[]) {\n  return function SelectComponent(props: CellEditComponentProps<TData, string>) {\n    return <SelectEditInput {...props} options={options} />;\n  };\n}\n\n// Utility function to create a number input with min/max validation\nexport function createNumberEditComponent<TData>(min?: number, max?: number) {\n  return function NumberComponent(props: CellEditComponentProps<TData, number>) {\n    const validate = (value: number) => {\n      if (min !== undefined && value < min) return false;\n      if (max !== undefined && value > max) return false;\n      return true;\n    };\n\n    const handleChange = (value: number) => {\n      if (validate(value)) {\n        props.onChange(value);\n      }\n    };\n\n    return <NumberEditInput {...props} onChange={handleChange} />;\n  };\n}\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/edit-presets.tsx",
      "content": "'use client';\n\nimport { CellEditConfig, EditBehaviors, QuickEditConfig } from './types';\nimport { TextEditInput, NumberEditInput, SelectEditInput, CheckboxEditInput, DateEditInput, EmailEditInput } from './edit-components';\n\n/**\n * Utility functions to create common edit configurations with maximum developer control\n */\n\n// Quick edit configurations for common scenarios\nexport function createQuickEdit<TData, TValue = any>(config: QuickEditConfig<TData, TValue>): CellEditConfig<TData, TValue> {\n  return {\n    enabled: true,\n    behavior: EditBehaviors.clickToEdit,\n    ...config,\n  };\n}\n\nexport function createClickToEdit<TData, TValue = any>(config: QuickEditConfig<TData, TValue>): CellEditConfig<TData, TValue> {\n  return {\n    enabled: true,\n    behavior: EditBehaviors.clickToEdit,\n    ...config,\n  };\n}\n\nexport function createClickWithButtons<TData, TValue = any>(config: QuickEditConfig<TData, TValue>): CellEditConfig<TData, TValue> {\n  return {\n    enabled: true,\n    behavior: EditBehaviors.clickWithButtons,\n    ...config,\n  };\n}\n\nexport function createDoubleClickToEdit<TData, TValue = any>(config: QuickEditConfig<TData, TValue>): CellEditConfig<TData, TValue> {\n  return {\n    enabled: true,\n    behavior: EditBehaviors.doubleClickToEdit,\n    ...config,\n  };\n}\n\n\n\n// Pre-configured edit components for common data types\nexport const EditPresets = {\n  // Text editing\n  text: {\n    clickToEdit: <TData,>() =>\n      createClickToEdit<TData, string>({\n        component: TextEditInput,\n        placeholder: 'Enter text...',\n      }),\n\n    withButtons: <TData,>() =>\n      createClickWithButtons<TData, string>({\n        component: TextEditInput,\n        placeholder: 'Enter text...',\n      }),\n\n    required: <TData,>() =>\n      createClickToEdit<TData, string>({\n        component: TextEditInput,\n        placeholder: 'Enter text...',\n        validate: (value) => (!value?.trim() ? 'This field is required' : null),\n      }),\n  },\n\n  // Number editing\n  number: {\n    basic: <TData,>() =>\n      createClickToEdit<TData, number>({\n        component: NumberEditInput,\n        placeholder: 'Enter number...',\n      }),\n\n    positive: <TData,>() =>\n      createClickToEdit<TData, number>({\n        component: NumberEditInput,\n        placeholder: 'Enter positive number...',\n        validate: (value) => (value < 0 ? 'Must be positive' : null),\n      }),\n\n    range: <TData,>(min: number, max: number) =>\n      createClickToEdit<TData, number>({\n        component: NumberEditInput,\n        placeholder: `Enter number (${min}-${max})...`,\n        validate: (value) => {\n          if (value < min) return `Must be at least ${min}`;\n          if (value > max) return `Must be at most ${max}`;\n          return null;\n        },\n      }),\n  },\n\n  // Boolean editing\n  boolean: {\n    checkbox: <TData,>() =>\n      createClickToEdit<TData, boolean>({\n        component: CheckboxEditInput,\n      }),\n  },\n\n  // Date editing\n  date: {\n    basic: <TData,>() =>\n      createClickToEdit<TData, string>({\n        component: DateEditInput,\n      }),\n\n    withButtons: <TData,>() =>\n      createClickWithButtons<TData, string>({\n        component: DateEditInput,\n      }),\n  },\n\n  // Email editing\n  email: {\n    basic: <TData,>() =>\n      createClickToEdit<TData, string>({\n        component: EmailEditInput,\n        placeholder: 'Enter email...',\n        validate: (value) => {\n          const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n          return value && !emailRegex.test(value) ? 'Invalid email format' : null;\n        },\n      }),\n  },\n};\n\n// Custom behavior builders for advanced scenarios\nexport const BehaviorBuilder = {\n  create: () => ({\n    mode: 'click' as 'click' | 'doubleClick',\n    saveOn: ['blur', 'enter'] as ('blur' | 'enter' | 'escape' | 'manual')[],\n    cancelOn: ['escape'] as ('blur' | 'enter' | 'escape' | 'manual')[],\n    showActionButtons: false,\n    buttonPosition: 'top-right' as 'top-right' | 'bottom-right',\n    autoFocus: true,\n    selectAllOnFocus: true,\n\n    // Fluent API for building behaviors\n    clickToEdit() {\n      this.mode = 'click';\n      return this;\n    },\n\n    doubleClickToEdit() {\n      this.mode = 'doubleClick';\n      return this;\n    },\n\n    saveOnBlur() {\n      if (!this.saveOn.includes('blur')) {\n        this.saveOn = [...this.saveOn, 'blur'];\n      }\n      return this;\n    },\n\n    saveOnEnter() {\n      if (!this.saveOn.includes('enter')) {\n        this.saveOn = [...this.saveOn, 'enter'];\n      }\n      return this;\n    },\n\n    withActionButtons(position: 'top-right' | 'bottom-right' = 'top-right') {\n      this.showActionButtons = true;\n      this.buttonPosition = position;\n      this.saveOn = ['manual'];\n      this.cancelOn = ['manual'];\n      return this;\n    },\n\n    withoutActionButtons() {\n      this.showActionButtons = false;\n      return this;\n    },\n\n    noAutoFocus() {\n      this.autoFocus = false;\n      return this;\n    },\n\n    noTextSelection() {\n      this.selectAllOnFocus = false;\n      return this;\n    },\n\n    build() {\n      return { ...this };\n    },\n  }),\n};\n\n// Example usage:\n/*\n// Simple text editing\nenableEditing: EditPresets.text.clickToEdit()\n\n// Number with validation\nenableEditing: EditPresets.number.range(0, 100)\n\n// Custom behavior\nenableEditing: {\n  enabled: true,\n  behavior: BehaviorBuilder.create()\n    .doubleClickToEdit()\n    .withActionButtons()\n    .noTextSelection()\n    .build(),\n  component: TextEditInput,\n  validate: (value) => value.length < 3 ? 'Too short' : null,\n}\n\n// Manual control\nenableEditing: createManualEdit({\n  component: MyCustomComponent,\n  onSave: async (value, row, column) => {\n    // Custom save logic\n    return await saveToAPI(value);\n  },\n})\n*/\n",
      "type": "registry:component"
    },
    {
      "path": "src/components/data-grid/index.ts",
      "content": "// Main components\nexport { DataGrid } from './data-grid';\nexport { DataGridHeader } from './data-grid-header';\nexport { DataGridBody } from './data-grid-body';\nexport { DataGridPagination } from './data-grid-pagination';\nexport { DataGridFilters } from './data-grid-filters';\nexport { DataGridActionDock } from './data-grid-action-dock';\nexport { CellContextMenu, HeaderContextMenu } from './data-grid-context-menu';\n\n// Editing components\nexport { EditableCell, DefaultTextInput } from './data-grid-editable-cell';\nexport {\n  TextEditInput,\n  NumberEditInput,\n  SelectEditInput,\n  CheckboxEditInput,\n  DateEditInput,\n  EmailEditInput,\n  createSelectEditComponent,\n  createNumberEditComponent,\n} from './edit-components';\n\n// Editing presets and utilities\nexport {\n  EditPresets,\n  BehaviorBuilder,\n  createQuickEdit,\n  createClickToEdit,\n  createClickWithButtons,\n  createDoubleClickToEdit,\n} from './edit-presets';\n\n// Context and hooks\nexport { useDataGrid } from './context';\n\n// Types\nexport type {\n  DataGridProps,\n  DataGridColumn,\n  DataGridAction,\n  DataGridState,\n  DataChangeParams,\n  CellContextMenuItem,\n  HeaderContextMenuItem,\n  DataGridContextValue,\n  CellEditConfig,\n  CellEditComponentProps,\n  CellEditMode,\n  CellEditTrigger,\n  CellEditBehavior,\n  QuickEditConfig,\n} from './types';\n\n// Export EditBehaviors constant\nexport { EditBehaviors } from './types';\n\n// Context menu utilities\nexport * from './context-menu-utils';\n",
      "type": "registry:component"
    }
  ]
}